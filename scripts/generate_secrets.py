#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Generate secure secrets for Community Edition installation.

This script generates:
- API_KEY_ENCRYPTION_KEY (32-byte key for encrypting user API keys)
- ROUNDTABLE_JWT_SECRET (JWT signing secret)
- ROUNDTABLE_JWT_REFRESH_SECRET (JWT refresh token secret)
- POSTGRES_USER (Database username)
- POSTGRES_PASSWORD (Database password)
- REDIS_PASSWORD (Redis authentication password)

Usage:
    python scripts/generate_secrets.py

Output:
    Creates or updates .env file with generated secrets
"""
import secrets
import os
import sys
from pathlib import Path

# Set UTF-8 encoding for Windows compatibility
if sys.platform == 'win32':
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')


def generate_encryption_key() -> str:
    """Generate a secure 32-byte encryption key."""
    return secrets.token_urlsafe(32)


def generate_jwt_secret() -> str:
    """Generate a secure JWT signing secret."""
    return secrets.token_urlsafe(48)


def generate_postgres_user() -> str:
    """Generate a secure PostgreSQL username (alphanumeric, lowercase)."""
    import string
    return ''.join(secrets.choice(string.ascii_lowercase + string.digits) for _ in range(12))


def generate_postgres_password() -> str:
    """Generate a secure PostgreSQL password."""
    return secrets.token_urlsafe(24)


def generate_redis_password() -> str:
    """Generate a secure Redis password."""
    return secrets.token_urlsafe(32)


def generate_community_password() -> str:
    """Generate a secure community edition authentication password."""
    return secrets.token_urlsafe(16)


def main():
    """Generate secrets and save to .env file."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Generate secure secrets for Community Edition")
    parser.add_argument('--force', action='store_true', help='Force regeneration even if .env exists')
    args = parser.parse_args()
    
    # Get project root directory
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    env_file = project_root / ".env"
    env_example = project_root / ".env.example"
    
    print("=" * 70)
    print("Crucible Community Edition - Secret Generation")
    print("=" * 70)
    print()
    
    # Check if .env already exists
    if env_file.exists() and not args.force:
        print(f"WARNING: .env file already exists at: {env_file}")
        print()
        try:
            response = input("Do you want to regenerate secrets? This will make existing encrypted API keys unreadable! (y/N): ")
            if response.lower() != 'y':
                print("Aborted. Keeping existing .env file.")
                print("Use --force flag to regenerate without prompting.")
                return
        except (EOFError, KeyboardInterrupt):
            print("\nAborted. Keeping existing .env file.")
            print("Use --force flag to regenerate without prompting.")
            return
        print()
    
    # Generate secrets
    print("Generating secure secrets...")
    encryption_key = generate_encryption_key()
    jwt_secret = generate_jwt_secret()
    jwt_refresh_secret = generate_jwt_secret()
    postgres_user = generate_postgres_user()
    postgres_password = generate_postgres_password()
    redis_password = generate_redis_password()
    community_password = generate_community_password()
    
    # Create .env content
    env_content = f"""# Crucible Community Edition Configuration
# Auto-generated by generate_secrets.py

# ============================================================================
# SECURITY - DO NOT SHARE THESE VALUES!
# ============================================================================

# API Key Encryption Key (32 characters)
# WARNING: If this changes, all encrypted API keys will become unreadable!
API_KEY_ENCRYPTION_KEY={encryption_key}

# Community Edition Authentication Password
# IMPORTANT: For production security, hash your password using:
#   cd service && python -m scripts.hash_password <your-password>
# Then set ROUNDTABLE_COMMUNITY_AUTH_PASSWORD to the generated hash.
# For now, using plain text (will work but less secure):
ROUNDTABLE_COMMUNITY_AUTH_PASSWORD={community_password}

# JWT Secrets (used for token signing)
ROUNDTABLE_JWT_SECRET={jwt_secret}
ROUNDTABLE_JWT_REFRESH_SECRET={jwt_refresh_secret}

# Database Credentials
# IMPORTANT: Save these values - you'll need them if you need to access the database directly
POSTGRES_USER={postgres_user}
POSTGRES_PASSWORD={postgres_password}

# Redis Credentials
# IMPORTANT: Save this value - Redis requires authentication
REDIS_PASSWORD={redis_password}

# ============================================================================
# OPTIONAL - Provider API Keys (if you want server-side defaults)
# ============================================================================
# Users can also set their own API keys in the Settings page after login

# OpenRouter API Key (optional - users can provide their own)
ROUNDTABLE_OPENROUTER_API_KEY=

# Eden AI API Key (optional - for AI research features)
ROUNDTABLE_EDEN_AI_API_KEY=

# ============================================================================
# OPTIONAL - LLM Rate Limiting Configuration
# ============================================================================
# Configure rate limiting for LLM API calls to prevent exceeding provider limits.

# Enable Rate Limiting (default: true - rate limiting enabled)
# You can change this in .env file if needed.
ROUNDTABLE_ENABLE_RATE_LIMITING=true

# LLM Rate Limit (Tokens Per Minute) - default: 100000
ROUNDTABLE_LLM_RATE_LIMIT_TPM=100000

# LLM Rate Limit Window (Seconds) - default: 60 (one minute window)
ROUNDTABLE_LLM_RATE_LIMIT_WINDOW_SECONDS=60
"""
    
    # Write to .env file
    with open(env_file, 'w', encoding='utf-8') as f:
        f.write(env_content)
    
    print(f"SUCCESS! Secrets generated successfully!")
    print()
    print(f"Created: {env_file}")
    print()
    print("=" * 70)
    print("IMPORTANT SECURITY NOTES")
    print("=" * 70)
    print()
    print("1. YOUR LOGIN PASSWORD:")
    print(f"   Password: {community_password}")
    print("   Email: admin@community.local")
    print("   SAVE THIS PASSWORD - it's shown here and in .env file")
    print()
    print("   For production security, hash your password:")
    print("   cd service && python -m scripts.hash_password <your-password>")
    print("   Then set ROUNDTABLE_COMMUNITY_AUTH_PASSWORD to the generated hash")
    print("   (Plain text passwords work but are less secure)")
    print()
    print("2. SAVE YOUR DATABASE CREDENTIALS!")
    print("   - POSTGRES_USER and POSTGRES_PASSWORD have been generated")
    print("   - Keep these secure - you'll need them for database access")
    print("   - Never commit .env to version control")
    print()
    print("3. SAVE YOUR REDIS PASSWORD!")
    print("   - REDIS_PASSWORD has been generated")
    print("   - Redis requires authentication - keep this secure")
    print("   - Never commit .env to version control")
    print()
    print("4. KEEP .env FILE SECURE!")
    print("   - Never commit .env to version control")
    print("   - Backup .env file in a secure location")
    print("   - If API_KEY_ENCRYPTION_KEY changes, users must re-enter their API keys")
    print()
    print("5. BACKUP YOUR .env FILE!")
    print("   If you lose this file, all encrypted API keys will be unrecoverable.")
    print()
    print("=" * 70)
    print()
    print("Next steps:")
    print("1. Hash your password (recommended for production):")
    print("   cd service && python -m scripts.hash_password <your-password>")
    print("   Update ROUNDTABLE_COMMUNITY_AUTH_PASSWORD in .env with the hash")
    print("2. Run: docker compose up -d")
    print("3. Access at: http://localhost:3000")
    print("4. Login with your password")
    print()


if __name__ == "__main__":
    main()
